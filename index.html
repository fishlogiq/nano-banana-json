const { GoogleAuth } = require('google-auth-library');
const express = require('express');

// ===== CONFIG =====
const PROJECT_ID = 'gen-lang-client-0859048251';
const LOCATION   = process.env.VERTEX_LOCATION || 'us-central1';
const GEMINI_API_MODEL = process.env.GEMINI_API_MODEL || 'gemini-2.5-flash';
const VERTEX_MODEL = process.env.VERTEX_MODEL || 'gemini-1.5-pro-002';

const auth = new GoogleAuth({ scopes: 'https://www.googleapis.com/auth/cloud-platform' });

// ===== HELPERS =====
const shopifyJsonUrl = (productUrl) => {
  const u = new URL(productUrl);
  const parts = u.pathname.replace(/\/+$/, '').split('/');
  const last = parts.pop();
  u.pathname = `/products/${last}.json`;
  return u.toString();
};

const stripHtml = (s = "") => 
  s.replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim();

const extractSizes = (s = "") =>
  Array.from(
    new Set(
      (s.match(/\b(?:\d{1,2}T|[XSML]{1,3}|\d{1,2}(?:\/\d{1,2})?)\b/gi) || [])
        .map(x => x.toUpperCase())
    )
  );

const detectAgeCategoryFromSizes = (sizes) => {
  const sizeNums = sizes
    .map(s => {
      const match = s.match(/(\d+)/);
      return match ? parseInt(match[1]) : null;
    })
    .filter(n => n !== null);
  
  if (sizeNums.length === 0) return null;
  
  const maxSize = Math.max(...sizeNums);
  
  if (maxSize <= 2) return "infant";
  if (maxSize <= 4) return "toddler";
  if (maxSize <= 8) return "child";
  if (maxSize <= 14) return "preteen";
  return "teen";
};

const detectAgeCategory = (title, productType, description, tags, sizes) => {
  const tagsStr = Array.isArray(tags) ? tags.join(" ") : (tags || "");
  const text = (title + " " + productType + " " + description + " " + tagsStr).toLowerCase();
  
  // Check for adult/men/women keywords FIRST
  if (text.includes("men") || text.includes("women") || text.includes("adult") ||
      text.includes("mens") || text.includes("womens") || text.includes("man's") || 
      text.includes("woman's") || text.includes("unisex") ||
      /\b(polo|dress shirt|button.?up|business|professional)\b/i.test(text)) {
    return "adult";
  }
  
  // Check for adult sizes
  const hasAdultSizes = sizes.some(s => /^(XS|S|M|L|XL|XXL|XXXL)$/i.test(s));
  if (hasAdultSizes) return "adult";
  
  // Check for baby/infant keywords or month sizes
  if (text.includes("infant") || text.includes("baby") || 
      text.match(/\b(0-3|3-6|6-9|9-12|12-18)\s*months?\b/i) ||
      sizes.some(s => /\d{1,2}M$/i.test(s))) {
    return "infant";
  }
  
  // Check for toddler keywords
  if (text.includes("toddler") || sizes.some(s => /[2-4]T/i.test(s))) {
    return "toddler";
  }
  
  const sizeBasedAge = detectAgeCategoryFromSizes(sizes);
  if (sizeBasedAge) return sizeBasedAge;
  
  if (text.includes("kids") || text.includes("girls") || text.includes("boys") || text.includes("child")) {
    return "child";
  }
  
  return "adult";
};

const detectGender = (title, productType, tags) => {
  const text = (title + " " + productType + " " + (Array.isArray(tags) ? tags.join(" ") : tags || "")).toLowerCase();
  
  if (text.includes("men") || text.includes("mens") || text.includes("man's") || text.includes("male")) return "men";
  if (text.includes("women") || text.includes("womens") || text.includes("woman's") || text.includes("female") || text.includes("ladies")) return "women";
  if (text.includes("girls") || text.includes("girl's")) return "girls";
  if (text.includes("boys") || text.includes("boy's")) return "boys";
  if (text.includes("unisex")) return "unisex";
  
  return "unisex";
};

const detectBottomType = (handle, title, productType) => {
  const text = (handle + " " + title + " " + productType).toLowerCase();
  
  if (/polo|shirt|tee|top|blouse/i.test(text) && !/set/i.test(text)) {
    return null;
  }
  
  if (/legging/i.test(text)) return "Legging";
  if (/short[-\s]?set|shorts?/i.test(text)) return "Short";
  if (/jogger|jog[-\s]?set/i.test(text)) return "Jogger";
  if (/pant/i.test(text)) return "Pant";
  
  return null;
};

const detectPattern = (title, description) => {
  const text = (title + " " + description).toLowerCase();
  const patterns = [
    "butterfly", "animal print", "leopard", "zebra", "heart", "floral", 
    "stripe", "polka dot", "tie dye", "rainbow", "star", "unicorn", "dinosaur",
    "princess", "mermaid", "superhero", "sports", "camo", "plaid", "t-rex", "t rex"
  ];
  
  for (const pattern of patterns) {
    if (text.includes(pattern)) {
      return pattern.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    }
  }
  
  return null;
};

const detectGarmentType = (title, description, productType) => {
  const text = (title + " " + description + " " + productType).toLowerCase();
  
  if (text.includes("hooded") || text.includes("hoodie")) return "Hooded";
  if (text.includes("fleece")) return "Fleece";
  if (text.includes("jersey")) return "Jersey";
  if (text.includes("polo")) return "Polo";
  if (text.includes("jacket")) return "Jacket";
  if (text.includes("sweater")) return "Sweater";
  
  return null;
};

const markdownToHtml = (md = '') => {
  let html = md || '';
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/^\s*-\s+(.+)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*?<\/li>\n?)+/gs, (m) => '<ul>\n' + m.trim() + '\n</ul>\n');

  const blocks = html.split(/\n\n+/).map(block => {
    block = block.trim();
    if (!block) return '';
    if (block.startsWith('<ul>') || block.startsWith('<h')) return block;
    if (!block.includes('\n')) return '<p>' + block + '</p>';
    return '<p>' + block.replace(/\n/g, ' ') + '</p>';
  }).filter(Boolean);
  return blocks.join('\n\n');
};

// ===== STRUCTURED JSON PROMPT GENERATOR =====
function generateCopywritingPrompt(productData) {
  const { title, vendor, handle, sizes, sku, city, productType, description, tags, bottomType, ageCategory, gender, pattern, garmentType } = productData;
  
  const sizesArray = extractSizes(sizes + " " + title);
  const sizesDisplay = sizesArray.length > 0 ? sizesArray.join(", ") : sizes;
  
  const ageCategoryDisplay = ageCategory === "toddler" ? "Toddler" : 
                              ageCategory === "infant" ? "Infant" :
                              ageCategory === "child" ? "Kids" :
                              ageCategory === "preteen" ? "Preteen" :
                              ageCategory === "teen" ? "Teen" : 
                              ageCategory === "adult" ? "Adult" : "Kids";
  
  const genderDisplay = gender === "girls" ? "Girls" : 
                        gender === "boys" ? "Boys" : 
                        gender === "men" ? "Men" :
                        gender === "women" ? "Women" :
                        gender === "unisex" ? "Unisex" : "Kids";
  
  const titleParts = [];
  if (pattern) titleParts.push(pattern);
  if (garmentType) titleParts.push(garmentType);
  if (bottomType) titleParts.push(bottomType);
  
  const isSet = bottomType || /set/i.test(title);
  const titleTheme = titleParts.length > 0 ? titleParts.join(" ") + " " : "";
  const titleEnding = isSet ? "Set" : (garmentType || "Item");
  
  let prompt = {
    "task": "Generate SEO-optimized Shopify product content for wholesale apparel",
    "product_details": {
      "original_title": title,
      "brand": vendor,
      "handle": handle,
      "sku": sku,
      "sizes_available": sizesDisplay,
      "age_category": ageCategory,
      "age_category_display": ageCategoryDisplay,
      "gender": gender,
      "gender_display": genderDisplay,
      "bottom_type": bottomType,
      "pattern_theme": pattern,
      "garment_type": garmentType,
      "product_type": productType,
      "shipping_location": city,
      "description_excerpt": description.slice(0, 200)
    }
  };
  
  return prompt;
}

// ===== GEMINI CALLER WITH STRUCTURED PROMPT =====
async function callGemini(productData) {
  const structuredPrompt = generateCopywritingPrompt(productData);
  
  const isSet = productData.bottomType || /set/i.test(productData.title);
  
  const promptText = `You are an expert Shopify product copywriter for wholesale apparel.

PRODUCT INFO:
Title: ${productData.title}
Brand: ${productData.vendor}
SKU: ${productData.sku}
Sizes: ${productData.sizes || 'S, M, L, XL'}
Age: ${structuredPrompt.product_details.age_category_display} ${structuredPrompt.product_details.gender_display}
Type: ${isSet ? 'Set' : 'Single Item'}
Pattern: ${productData.pattern || 'Standard'}
Garment: ${productData.garmentType || ''}
Bottom: ${productData.bottomType || 'N/A'}
Ships: ${productData.city}

CREATE:

1. title: "${structuredPrompt.product_details.age_category_display} ${structuredPrompt.product_details.gender_display} ${productData.pattern ? productData.pattern + ' ' : ''}${productData.garmentType ? productData.garmentType + ' ' : ''}${productData.bottomType ? productData.bottomType + ' ' : ''}${isSet ? 'Set' : (productData.garmentType || 'Item')} – ${productData.sku}"
Max 70 chars. Natural and descriptive.

2. seo_title: Optimized version with " ( ${productData.sku} )"
Max 65 chars. Keywords + ( SKU ).

3. seo_description: 140-155 chars
Start with "Wholesale". End with "Ships from ${productData.city}."
Mention key features.

4. description_markdown:
Opening sentence about the ${isSet ? 'set' : 'item'}.

**Features & Details**
- **Brand:** ${productData.vendor}
- **Sizes:** ${productData.sizes || 'S, M, L, XL'}
${isSet ? '- **Top:** [describe]\n- **Bottom:** [describe]' : '- **Material:** [describe]\n- **Features:** [describe]'}
- **Care:** Machine wash cold
- **Style/SKU:** ${productData.sku}

Closing about wholesale value and ${productData.city}.

5. category: ${productData.ageCategory === 'adult' ? 
  (productData.gender === 'men' ? "Men's Apparel" : 
   productData.gender === 'women' ? "Women's Apparel" : "Adult Apparel") :
  `Choose from: Toddler Girls Legging Sets, Toddler Girls Short Sets, Kids Apparel Sets`}

RULES:
- Sizes = "${productData.sizes || 'S, M, L, XL'}" NOT ${productData.sku}
- Use markdown ** for bold
- SKU appears in title, seo_title, and Style/SKU only

Return valid JSON: {title, seo_title, seo_description, description_markdown, category}`;

  const OUTPUT_SCHEMA = {
    type: 'object',
    properties: {
      title: { type: 'string' },
      seo_title: { type: 'string' },
      seo_description: { type: 'string' },
      description_markdown: { type: 'string' },
      category: { type: 'string' }
    },
    required: ['title', 'seo_title', 'seo_description', 'description_markdown', 'category']
  };

  const fallback = () => {
    const ageCat = productData.ageCategory === "toddler" ? "Toddler" : 
                   productData.ageCategory === "infant" ? "Infant" :
                   productData.ageCategory === "adult" ? "Adult" : "Kids";
    const genderCat = productData.gender === "girls" ? "Girls" : 
                      productData.gender === "boys" ? "Boys" :
                      productData.gender === "men" ? "Men" :
                      productData.gender === "women" ? "Women" : "Kids";
    const pattern = productData.pattern ? ` ${productData.pattern}` : "";
    const garment = productData.garmentType ? ` ${productData.garmentType}` : "";
    const bottom = productData.bottomType ? ` ${productData.bottomType}` : "";
    const isSetFb = productData.bottomType || /set/i.test(productData.title);
    
    console.log('⚠️ WARNING: Using fallback function - Gemini did not return valid response');
    
    return {
      title: `${ageCat} ${genderCat}${pattern}${garment}${bottom} ${isSetFb ? 'Set' : (productData.garmentType || 'Item')} – ${productData.sku}`.trim(),
      seo_title: `${ageCat} ${genderCat}${pattern} ${isSetFb ? 'Set' : 'Item'} ( ${productData.sku} )`,
      seo_description: `Wholesale ${ageCat} ${genderCat}${pattern.toLowerCase()} apparel. Comfortable fabric, quality construction. Ships from ${productData.city}.`,
      description_markdown:
        `Comfortable and stylish ${ageCat.toLowerCase()} ${genderCat.toLowerCase()} ${isSetFb ? 'set' : 'item'} perfect for everyday wear${isSetFb ? ' and play' : ''}.\n\n` +
        `**Features & Details**\n` +
        `- **Brand:** ${productData.vendor}\n` +
        (productData.sizes ? `- **Sizes:** ${productData.sizes}\n` : ``) +
        (isSetFb ? `- **Top:** Quality construction with comfortable fit\n- **Bottom:** Matching coordinated design\n` : `- **Material:** Quality fabric construction\n- **Features:** Professional design and finish\n`) +
        `- **Style/SKU:** ${productData.sku}\n\n` +
        `Perfect for wholesale and boutique buyers. Ships from ${productData.city}.`,
      category: productData.ageCategory === 'adult' ? 
        (productData.gender === 'men' ? "Men's Apparel" : 
         productData.gender === 'women' ? "Women's Apparel" : "Adult Apparel") :
        (productData.bottomType === 'Legging' ? `${ageCat} ${genderCat} Legging Sets` :
         productData.bottomType === 'Short' ? `${ageCat} ${genderCat} Short Sets` :
         `${ageCat} ${genderCat} Jog Sets`)
    };
  };

  const robustParse = (raw) => {
    if (!raw || typeof raw !== 'string') throw new Error('empty');
    let t = raw.trim().replace(/^```(?:json)?\s*/i, '').replace(/```$/i, '').trim();
    try { return JSON.parse(t); } catch {}
    const m = t.match(/\{[\s\S]*\}/);
    if (m) return JSON.parse(m[0]);
    throw new Error('no-json');
  };

  if (process.env.GEMINI_API_KEY) {
    const { GoogleGenerativeAI } = await import('@google/generative-ai');
    const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    const model = genAI.getGenerativeModel({ model: GEMINI_API_MODEL });

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: [{ text: promptText }] }],
      generationConfig: {
        temperature: 0.8,
        maxOutputTokens: 2048,
        responseMimeType: 'application/json',
        responseSchema: OUTPUT_SCHEMA
      }
    });

    const r = result?.response;
    let jsonText = typeof r?.text === 'function' ? r.text() : '';
    if (!jsonText) {
      const part = r?.candidates?.[0]?.content?.parts?.find(p => typeof p?.text === 'string');
      jsonText = part?.text || '';
    }
    if (!jsonText) {
      console.error('❌ Gemini returned empty; blockReason:', r?.promptFeedback?.blockReason || 'unknown');
      console.error('Full response object:', JSON.stringify(r, null, 2));
      return fallback();
    }

    console.log('✅ Gemini response received, parsing...');

    let out;
    try { out = robustParse(jsonText); }
    catch (e) {
      console.error('❌ Gemini JSON parse error:', e.message);
      console.error('First 300 chars:', jsonText.slice(0, 300));
      return fallback();
    }

    console.log('✅ Successfully parsed Gemini response');

    if (!out.title.includes(productData.sku))
      out.title = out.title.replace(/\s*$/, ` – ${productData.sku}`);
    if (!out.seo_title.includes(productData.sku))
      out.seo_title = out.seo_title.replace(/\s*$/, ` ( ${productData.sku} )`);
    
    return out;
  }

  // Vertex AI fallback
  const client = await auth.getClient();
  const tokenResp = await client.getAccessToken();
  const accessToken = tokenResp?.token || tokenResp;
  if (!accessToken) throw new Error('Access token missing');

  const base = `https://${LOCATION}-aiplatform.googleapis.com/v1`;
  const modelPath = `projects/${PROJECT_ID}/locations/${LOCATION}/publishers/google/models/${VERTEX_MODEL}:generateContent`;
  const url = `${base}/${modelPath}`;

  const resp = await fetch(url, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      contents: [{ role: 'user', parts: [{ text: promptText }] }],
      generationConfig: {
        temperature: 0.8,
        maxOutputTokens: 2048,
        responseMimeType: 'application/json',
        responseSchema: OUTPUT_SCHEMA
      }
    })
  });

  if (!resp.ok) {
    const e = await resp.text();
    throw new Error(`Gemini (Vertex) error: ${resp.status} - ${e}`);
  }

  const data = await resp.json();
  const textPart = data?.candidates?.[0]?.content?.parts?.find?.(p => typeof p?.text === 'string');
  const jsonText = textPart?.text || '';
  if (!jsonText) {
    console.error('❌ Vertex returned empty; reason:',
      data?.promptFeedback?.blockReason || data?.candidates?.[0]?.finishReason || 'unknown');
    return fallback();
  }

  console.log('✅ Vertex response received, parsing...');

  let out;
  try { out = robustParse(jsonText); }
  catch (e) {
    console.error('❌ Vertex JSON parse error:', e.message);
    return fallback();
  }

  console.log('✅ Successfully parsed Vertex response');

  if (!out.title.includes(productData.sku))
    out.title = out.title.replace(/\s*$/, ` – ${productData.sku}`);
  if (!out.seo_title.includes(productData.sku))
    out.seo_title = out.seo_title.replace(/\s*$/, ` ( ${productData.sku} )`);
  
  return out;
}

// ===== MAIN HANDLER =====
async function handler(req, res) {
  res.set('Access-Control-Allow-Origin', '*');
  if (req.method === 'OPTIONS') {
    res.set('Access-Control-Allow-Methods', 'POST');
    res.set('Access-Control-Allow-Headers', 'Content-Type');
    return res.status(204).send('');
  }

  try {
    const { product_url, city = 'Miami, FL' } = req.body || {};
    if (!product_url) return res.status(400).json({ error: 'Missing product_url' });

    console.log('Fetching Shopify product:', product_url);
    const apiUrl = shopifyJsonUrl(product_url);
    const shopifyRes = await fetch(apiUrl);
    if (!shopifyRes.ok) throw new Error('Failed to fetch Shopify product');
    const { product } = await shopifyRes.json();
    if (!product) throw new Error('Product not found');

    console.log('Product title:', product.title);

    const handle = product.handle || '';
    const title = product.title || '';
    const description = stripHtml(product.body_html || '');
    const tags = product.tags || [];
    
    const sku = product.variants?.[0]?.sku || String(product.id) || '';
    
    console.log('=== SIZE EXTRACTION ===');
    console.log('SKU:', sku);
    
    let allSizes = [];
    for (const v of (product.variants || [])) {
      const opt2 = String(v.option2 || '');
      const opt1 = String(v.option1 || '');
      
      // Check option2 first (common for sizes)
      if (opt2 && /(\d{1,2}-\d{1,2}-\d{1,2}|[XSML]|T|\/)/i.test(opt2)) {
        console.log(`Using option2: ${opt2}`);
        allSizes.push(opt2);
      } else if (opt1 && opt1 !== sku && /(\d{1,2}T|[XSML]|\/)/i.test(opt1)) {
        console.log(`Using option1: ${opt1}`);
        allSizes.push(opt1);
      }
    }
    
    // Split and format sizes
    const splitSizes = allSizes.flatMap(s => {
      const sizeStr = String(s).trim();
      
      // Month format: 12-18-24 → 12M, 18M, 24M
      if (/^\d{1,2}-\d{1,2}-\d{1,2}$/.test(sizeStr)) {
        return sizeStr.split('-').map(sz => sz.trim() + 'M');
      }
      
      // Adult sizes: S-M-L-XL → S, M, L, XL
      if (/-/.test(sizeStr) && /[SMLX]/i.test(sizeStr)) {
        return sizeStr.split('-').map(sz => sz.trim());
      }
      
      return [sizeStr];
    });
    
    // Filter valid sizes
    const validSizes = splitSizes.filter(s => {
      const sz = String(s).trim();
      if (sz === sku) return false;
      if (/\d{1,2}T/i.test(sz)) return true;
      if (/\d{1,2}M$/i.test(sz)) return true;
      if (/^[XSML]{1,3}$/i.test(sz)) return true;
      if (/^\d{1,2}$/.test(sz) && parseInt(sz) <= 20) return true;
      if (/^\d{1,2}\/\d{1,2}$/.test(sz)) return true;
      return false;
    });
    
    let sizes = validSizes.join(', ');
    console.log('Extracted sizes:', sizes);
    
    // Fallback
    let ageCategory = 'child';
    
    if (!sizes) {
      const tempSizes = extractSizes(title + ' ' + description);
      ageCategory = detectAgeCategory(title, product.product_type, description, tags, tempSizes);
      
      if (ageCategory === 'adult') sizes = 'S, M, L, XL';
      else if (ageCategory === 'infant') sizes = '12M, 18M, 24M';
      else if (ageCategory === 'toddler') sizes = '2T, 3T, 4T';
      else sizes = '4, 6, 8, 10';
      
      console.log('Using fallback sizes:', sizes);
    }
    
    console.log('FINAL SIZES:', sizes);

    const finalSizesArray = extractSizes(sizes + " " + title);
    ageCategory = detectAgeCategory(title, product.product_type, description, tags, finalSizesArray);
    const gender = detectGender(title, product.product_type, tags);
    const bottomType = detectBottomType(handle, title, product.product_type || '');
    const pattern = detectPattern(title, description);
    const garmentType = detectGarmentType(title, description, product.product_type || '');

    console.log('Detections:', { ageCategory, gender, bottomType, pattern, garmentType });

    const productData = {
      title,
      vendor: product.vendor || '',
      handle,
      sizes,
      sku,
      city,
      productType: product.product_type || '',
      description,
      tags,
      ageCategory,
      gender,
      bottomType,
      pattern,
      garmentType,
      variants: product.variants || []
    };

    console.log('Calling Gemini...');
    const aiResult = await callGemini(productData);
    console.log('✅ AI result received');

    const descriptionHtml = markdownToHtml(aiResult.description_markdown);

    return res.json({
      success: true,
      outputs: {
        title: aiResult.title,
        product_title: aiResult.title,
        seo_title: aiResult.seo_title,
        seo_description: aiResult.seo_description,
        seo_meta_description: aiResult.seo_description,
        description_markdown: aiResult.description_markdown,
        description_html: descriptionHtml,
        product_description: aiResult.description_markdown,
        url_handle: `/products/${product.handle}`,
        category: aiResult.category
      }
    });
  } catch (error) {
    console.error('❌ Error:', error);
    console.error('Stack:', error.stack);
    return res.status(500).json({ 
      success: false, 
      error: error.message
    });
  }
}

// ===== EXPORT FOR CLOUD FUNCTIONS =====
exports.shopifyproductgenerator = handler;

// ===== OPTIONAL SERVER FOR CLOUD RUN =====
if (!process.env.FUNCTION_TARGET) {
  const app = express();
  app.use(express.json());
  app.get('/', (req, res) => res.send('OK'));
  app.post('/shopifyproductgenerator', handler);
  const port = process.env.PORT || 8080;
  app.listen(port, () => console.log(`HTTP server listening on ${port}`));
}
